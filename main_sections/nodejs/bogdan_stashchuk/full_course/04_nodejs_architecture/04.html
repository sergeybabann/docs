<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>04 Архитектура NodeJS</title>
    <link rel="stylesheet" href="../../../../../css/normalize.css">
    <link rel="stylesheet" href="../../../../../css/vars.css">
    <link rel="stylesheet" href="../../../../../css/main.css">
    <link rel="stylesheet" href="../../../../../css/header.css">
    <link rel="stylesheet" href="../../../../../css/content.css">
    <link rel="stylesheet" href="../../../../../css/sidebar_1.css">
    <link rel="stylesheet" href="../../../../../css/sidebar_2.css">
    <link rel="stylesheet" href="../../../../../css/footer.css">
    <link rel="stylesheet" href="../../../../../css/templates.css">
</head>

<body>

    <div class="wrapper">
        <!----- HEADER ----->
        <div class="header general__area-1">
            <a name="HEADER"></a>
            <div class="header__space">
                <div class="header__descr">
                    <h1 class="header__h1">
                        Обучающий<br> курс
                    </h1>
                    <span class="header__descr-1">Полный курс NodeJS
                    </span>
                    <ul class="header__descr-2">
                        <li>Источник: Udemy</li>
                        <li>Автор: Богдан Сташчук</li>
                        <li>Спецификация: NodeJS</li>
                    </ul>
                </div><!--tutorial__descr-->
                <ul class="header__navmenu-list">
                    <li class="header__navmenu-item">
                        <a href="../../../../../index.html" class="header__navmenu-link">Главная страница сайта</a>
                    </li>
                    <li class="header__navmenu-item">
                        <a href="../../../nodejs.html" class="header__navmenu-link">Курсы NodeJS</a>
                    </li>
                    <li class="header__navmenu-item">
                        <a href="../course.html" class="header__navmenu-link">Главная
                            страница курса</a>
                    </li>
                </ul>
            </div><!--header__space-->
        </div><!--header-->




        <!----- ASIDE-1 ----->
        <div class="aside-1 general__area-1">
            <ul class="aside-1__index-search-list">
                <li class="aside-1__index-search-item">
                    <a class="aside-1__index-search-link" href="#"></a>
                </li>
            </ul><!--aside-1__index-search-list-->
        </div><!--aside-1-->






        <!----- CONTENT ----->
        <div class="main general__area-1">
            <h2 class="main__h2">4 Архитектура NodeJS</h2>
            <div class="main__wrapper">

                <!----- Как работает Node.js ----->
                <a name="0.01"></a>
                <div class="main__title-1">Как работает Node.js</div>
                <p class="main__subtitle-1">Двигатель, основа NodeJS - V8 Engine</p>
                <p class="main__p">V8 Engine - это реализация стандартов JavaScript. Такой же двигатель используется в
                    веб-браузере Google Chrome. Этот двигатель отвечает за интерпретацию и выполнение кода JavaScript.
                </p>

                <p class="main__subtitle-1">
                    Встроенные модули
                </p>
                <p class="main__p">
                    В NodeJS есть много встроенных модулей, и такие модули отсутствуют в веб-браузерах. Благодаря таким
                    модулям можно выполнять различные операции по взаимодействию с компьютером и операционной системой.
                </p>
                <p class="main__p">
                    Встроенные модули в NodeJS:
                </p>
                <ul class="main__list">
                    <li class="main__list-item">path</li>
                    <li class="main__list-item">os</li>
                    <li class="main__list-item">fs</li>
                    <li class="main__list-item">http</li>
                </ul>
                <p class="main__p">
                    Все эти модули являются средствами взаимодействия с операционной системой. Различные API, которые
                    предоставляются вам NodeJS, обеспечивают работу с файловой системой, с компьютерной сетью,
                    процессором и так далее.
                </p>

                <p class="main__subtitle-1">
                    Компонент LibUV
                </p>
                <p class="main__p">
                    LibUV - это библиотека, написанная на C++, которая обеспечивает поддержку неблокирующих операций
                    ввода-вывода. Между модулями и библиотекой LibUV есть посредники. И получается, что встроенные
                    модули в NodeJS являются надстройкой над функционалом, который находится в LibUV. С помощью
                    посредников C++ Bindings происходит как раз связь встроенных модулей в NodeJS и функционала LibUV.
                </p>
                <p class="main__p">
                    Это позоляет коду, написанному на JavaScript, получать доступ к функциям, написанным в библиотеке
                    LibUV.
                </p>

                <p class="main__subtitle-1">
                    Внешние модули в NodeJS
                </p>
                <p class="main__p">
                    Существует много разных внешних модулей в NodeJS
                </p>

                <p class="main__subtitle-1">
                    Потоки и процессы
                </p>
                <p class="main__p">
                    Поток (thread) позволяет выполнять программу(код). При этом программу можно выполнять как в
                    однопоточном режиме, так и в многопоточном.
                </p>
                <p class="main__p">
                    Процесс (process) - это запущенная программа.
                </p>
                <p class="main__p">
                    Как связаны потоки и процессы? В одном процессе может быть несколько потоков. Если процесс имеет
                    несколько потоков, то один и тот же код может выполняться паралельно в несколько потоках. Если мы
                    говорим о модели с запросами и ответами, допустим у нас есть клиенты, которые подключаются к
                    серверам, и они отправляют на сервер запросы, то можно организовать процесс таким образом, что
                    каждый запрос от клиентов будет обрабатываться отдельным потоком. То есть отдельный поток на
                    отдельный запрос.
                </p>
                <p class="main__p">
                    Таким образом можно организовать функционал паралельной обработки различных запросов. Но это не
                    NodeJS. NodeJS непосредственно не позволяет создавать много потоков, по одному на каждый запрос
                    клиента, либо на любое другое действие, например, на запрос по работе с базой данных.
                </p>

                <p class="main__subtitle-1">
                    Модель в NodeJS
                </p>
                <p class="main__p">
                    В NodeJS есть только один поток, то есть в рамках одного процесса NodeJS работает один поток,
                    который обрабатывает все запросы от клиентов. В рамках этого же потока выполняются все другие
                    действия. NodeJS может выполнять только одну операцию в каждый момент времени, и пока эта операция
                    выполняется, другие операции ожидают своей очереди.
                </p>
                <p class="main__p">
                    Например, если в NodeJS вы решили записать много данных в один файл, и начали запись, это все
                    выполняется в одном потоке. Все остальные запросы и задачи ожидают, пока вы не закончите запись в
                    этот большой файл.
                </p>




                <!----- Блокирующие и неблокирующие операции ----->
                <a name="0.02"></a>
                <div class="main__title-1">Блокирующие и неблокирующие операции</div>
                <p class="main__subtitle-1">Обработка многопоточных запросов</p>
                <p class="main__p">Обработка многопоточности в NodeJS происходит благодаря асинхронным неблокирующим
                    операциям. И для этого существует LibUV. И благодаря этому в NodeJS можно выполнять различные
                    операции ввода-вывода паралельно.
                </p>

                <p class="main__subtitle-1">
                    Блокирующая операция
                </p>
                <p class="main__p">
                    Предположим, что у нас есть сервер NodeJS, на нем запущен процесс NodeJS, и в рамках этого процесса
                    у нас работает 1 поток, в рамках которого и выполняется весь код. И допустим у нас есть база данных,
                    к которой сервер посылает запросы. Напрмиер, от клиента на сервер приходит http-запрос. Клиент
                    запрашивает какие-то данные. Для того, чтобы сформировать ответ, серверу необходимо отправить запрос
                    в базу данных.
                </p>
                <p class="main__p">
                    После получения http-запроса от клиента, поток на сервере блокируется. Отправляется запрос в базу
                    данных, например, на чтение данных. Зачастую, база данных находится на другом сервере, и получение
                    ответа от базы данных занимает определенное время. Пока сервер ожидает ответа от базы данных, код в
                    потоке далее не выполняется, потому что сейчас ожидается ответ от базы данных.
                </p>
                <p class="main__p">
                    Когда мы получили на сервере ответ от базы данных, только тогда поток разблокируется, и становится
                    доступным для выполнения других задач.
                </p>

                <p class="main__subtitle-1">
                    Неблокирующая операция
                </p>
                <p class="main__p">
                    Получаем http-запрос от клиента, обрабатываем его в потоке, при этом мы отправляем запрос на
                    чтение в базу данных, но поток при этом не блокируется. И мы можем на сервере выполнять другие
                    задачи, пока мы ожидаем ответа от сервера. Операция чтения выполняется в фоновом режиме, при этом
                    другие операции продолжают выполняться в потоке. В единственном потоке, который доступен в NodeJS.
                </p>
                <p class="main__p">
                    И когда мы получили результат из базы данных, мы его обрабатываем и отправляем ответ клиенту.
                </p>
                <p class="main__p note">
                    Возникает вопрос, как же, в таком случае, мы помним, скажем так, о запросе, который был послан в
                    базу данных, и корректно обрабатываем результат, когда мы его получили от сервера? То есть как это
                    работает, если мы поток не блокируем? Если мы не ожидаем от сервера ответа в рамках одного потока.
                </p>
                <p class="main__p">
                    Прежде чем отвечать на этот вопрос посмотрим на примеры:
                </p>

                <!----- Папка 01. ----->
                <p class="main__subtitle-1">
                    Папка 01. Пример Блокирующей операции
                </p>
                <pre>
                    <code>
                        const fs = require('fs')

                        const data = fs.readFileSync('./test.txt', 'utf8')
                        console.log('File reading finished')
                        
                        console.log('Continue...')    
                    </code>
                </pre>
                <p class="main__p">
                    В этом примере выполняется чтение из файла. Мы импортируем модуль fs, используя функцию require:
                </p>
                <pre>
                    <code>
                        const fs = require('fs')  
                    </code>
                </pre>
                <p class="main__p">
                    И далее мы вызываем метод readFileSync:
                </p>
                <pre>
                    <code>
                        const data = fs.readFileSync('./test.txt', 'utf8')
                    </code>
                </pre>
                <p class="main__p">
                    То есть мы выполняем операцию чтения файла под названием test.txt в блокирующем формате.
                    То есть получается, что пока мы читаем файл на этой строке, код далее не выполняется. И только когда
                    мы закончили операцию чтения файла, и присвоили результат переменной data, мы продолжаем выполнение
                    кода.
                </p>
                <p class="main__p">
                    И только после окончания чтения файла вы увидите в терминале вывод: File reading finished<br>
                    И потом увидите вывод: Continue
                </p>
                <p class="main__p">
                    То есть в этом примере оба вывода в консоль выполняются после окончания операции чтения файла.
                </p>
                <p class="main__p">
                    То есть получается, что чтение файла на этой строке...
                </p>
                <pre>
                    <code>
                        const data = fs.readFileSync('./test.txt', 'utf8')
                    </code>
                </pre>
                <p class="main__p">
                    ...блокирует выполнение других частей кода, и другие операции не выполняются.
                </p>
                <p class="main__p">
                    Это блокирующая операция в NodeJS. И выполнять такую работу с файлами в синхронном режиме вы можете
                    благодаря встроенному модулю fs.<br>
                    fs - модуль по работе с файлами в NodeJS.
                </p>

                <!----- Папка 02. ----->
                <p class="main__subtitle-1">
                    Папка 02. Пример Неблокирующей операции
                </p>
                <pre>
                    <code>
                        const fs = require('fs')
                        fs.readFile('./test.txt', 'utf8', (err, data) => {
                            if (!err) {
                                console.log('File reading finished')
                            }
                        })
                        
                        console.log('Continue...') // выполняется до окончания чтения файла
                    </code>
                </pre>

                <p class="main__p">
                    В данном случае вместо метода readFileSync мы вызываем метод readFile - чтение файла.
                    Этот метод работает в неблокирующем стиле.
                </p>
                <p class="main__p">
                    На этой строке мы указываем название файла - test.txt, кодировку - utf8, и 3-им аргументом мы
                    передаем callback функцию - (err, data). Эта callback функция имеет 2 параметра: 1) ошибка 2)
                    данные:
                </p>
                <pre>
                    <code>
                        fs.readFile('./test.txt', 'utf8', (err, data) => {
                    </code>
                </pre>
                <p class="main__p">
                    Так вот, эта callback функция будет вызвана по окончанию чтения из файла.
                </p>

                <p class="main__p">
                    То есть когда мы закончим операцию чтения из файла: fs.readFile('./test.txt',<br>
                    будет автоматически вызвана эта функция: (err, data)<br>
                    и данные, которые мы прочли из файла будут переданы 2-ым аргументом. 2-ой аргумент data
                </p>
                <p class="main__p">
                    При этом, если возникла ошибка, то передастся ошибка в качестве значения для 1-ого параметра. 1-ый
                    параметр err
                </p>
                <p class="main__p">
                    И здесь в этой callback функции мы проверяем:<br>
                    Если ошибки нет, то тогда мы выводим в консоль текст: File reading finished
                </p>
                <pre>
                    <code>
                        if (!err) {
                            console.log('File reading finished')
                        }
                    </code>
                </pre>

                <p class="main__p">
                    И получается, что в таком случае код на последней строке...
                </p>
                <pre>
                    <code>
                        console.log('Continue...') // выполняется до окончания чтения файла
                    </code>
                </pre>
                <p class="main__p">
                    ...будет выполнен до окончания чтения файла.
                </p>

                <p class="main__p">
                    То есть вызывается функция readFile, мы начинаем процесс чтения из файла, и все, забываем об этом
                    запросе, и продолжаем выполнение кода. А вот, когда операция чтения из файла завершится, будет
                    автоматически вызвана вот эта функция:
                </p>
                <pre>
                    <code>
                        if (!err) {
                            console.log('File reading finished')
                        }
                    </code>
                </pre>
                <p class="main__p">
                    И код в этой функции будет выполнен так, как мы с вами обсудили. Но это уже произойдет после вывода
                    в терминал текста Continue.
                </p>











                <!----- 3 Libuv с циклом событий и пулом потоков ----->
                <a name="0.03"></a>
                <div class="main__title-1">LIBUV с циклом событий и пулом потоков</div>
                <p class="main__subtitle-1">Что позволяет выполнять в NodeJS операции асинхронно, вне основного потока?
                </p>
                <p class="main__p note">
                    Выполние в NodeJS операций асинхронно, вне основного потока, возможно благодаря библиотеке LIBUV.
                    Именно библиотека LIBUV обеспечивает поддержку асинхронных неблокирующих операций.
                </p>
                <p class="main__subtitle-1">
                    Асинхронная операция
                </p>
                <p class="main__p note">
                    Асинхронная операция - это операция, в которой мы получаем результат операции через какое-то время.
                </p>

                <p class="main__p">
                    Например, мы отправили какой-либо запрос в базу данных и ожидаем ответа. Ответ может прийти через 3
                    миллисекунды, через 2 секунды, или вообще не прийти. Мы не знаем когда придет ответ от базы данных.
                </p>

                <p class="main__p">
                    Второй пример. Мы допустим отправляем DNS запрос, для того чтобы по доменному имени получить
                    IP-адрес удаленного сервера. Такие операции называются асинхронными. Мы начинаем какое-то действие,
                    отправляем запрос, либо же начинаем запись в файл, но не знаем когда эта операция завершится.
                </p>

                <p class="main__subtitle-1">
                    Неблокирующая операция
                </p>

                <p class="main__p note">
                    Неблокирующая операция - это операция, которая не блокирует основной единственный поток в NodeJS.
                </p>
                <p class="main__p note">
                    Задача разработчика состоит планировать код так, чтобы вы выполняли все операции неблокирующим
                    образом. То есть писать код так, чтобы все асинхронные операции выполнялись без блокирования
                    основного потока.
                </p>

                <p class="main__subtitle-1">
                    LIBUV
                </p>
                <p class="main__p">
                    В LIBUV есть 2 основные составляющие части.
                </p>
                <p class="main__p">
                    1) Event loop - цикл событий
                </p>
                <p class="main__p">
                    2) Thread pool - пул потоков
                </p>
                <p class="main__p">
                    Event loop. С помощью цикла событий в LIBUV в NODEJS можно выполнять асинхронные операции. И в
                    LIBUV этот
                    функционал реализован с помощью callback функции. У каждого события есть соответствующая callback
                    функция, которая вызывается в какой-то момент в будущем после того, как мы закончили определенное
                    действие. Например, закончили запись в файл, либо же получили ответ от сервера и т.д.
                </p>

                <p class="main__p">
                    Thread pool. Пул потоков используется для обработки блокирующих операций. Тех операций, которые
                    нельзя выполнить в асинхронном формате.
                </p>

            </div><!---------------main__wrapper--------------->
        </div><!--------------------main-------------------->






        <!----- ASIDE-2 ----->
        <div class="aside-2 general__area-1">
            <ul class="aside-2__index-search-list">
                <li class="aside-2__index-search-item">
                    <a class="aside-2__index-search-link" href="#0.01">Как работает Node.js</a>
                </li>
                <li class="aside-2__index-search-item">
                    <a class="aside-2__index-search-link" href="#0.02">Блокирующие и неблокирующие операции</a>
                </li>
                <li class="aside-2__index-search-item">
                    <a class="aside-2__index-search-link" href="#0.03">Libuv с циклом событий и пулом потоков</a>
                </li>
            </ul><!--aside-2__index-search-list-->
        </div><!--aside_2-->













        <!----- FOOTER ----->
        <a name="FOOTER"></a>
        <div class="footer general__area-1">Footer</div>
    </div><!--wrapper-->



</body>

</html>